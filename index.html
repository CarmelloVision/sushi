<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  html, body { background: #000; width: 100%; height: 100%; overflow: hidden; }

  #c {
    position: fixed;
    top: 0; left: 0;
    width: 100vw; height: 100vh;
    background: #000;
    z-index: 0;
  }

  #fade {
    position: fixed;
    bottom: 0; left: 0;
    width: 100%; height: 200px;
    background: linear-gradient(to bottom, transparent, #000);
    pointer-events: none;
    z-index: 2;
    transition: opacity 0.5s ease;
  }

  #scroller {
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
    overflow-y: scroll;
    z-index: 3;
    -webkit-overflow-scrolling: touch;
  }
  #scroller::-webkit-scrollbar { display: none; }
  #scroller { scrollbar-width: none; }
  #scroller.done { pointer-events: none; overflow: hidden; }

  #scroll-content { height: 400vh; width: 100%; }

  #hint {
    position: fixed;
    bottom: 36px; left: 50%;
    transform: translateX(-50%);
    z-index: 4;
    opacity: 0;
    transition: opacity 0.8s ease;
    pointer-events: none;
    display: flex; flex-direction: column;
    align-items: center; gap: 8px;
  }
  #hint.visible { opacity: 1; }
  #hint span {
    color: rgba(255,255,255,0.4);
    font-family: Georgia, serif;
    font-size: 10px;
    letter-spacing: 0.3em;
    text-transform: uppercase;
  }
  #hint svg { animation: bounce 1.5s ease-in-out infinite; }
  @keyframes bounce {
    0%, 100% { transform: translateY(0); }
    50% { transform: translateY(7px); }
  }

  #loading {
    position: fixed; inset: 0;
    background: #000;
    display: flex; flex-direction: column;
    align-items: center; justify-content: center;
    z-index: 99;
    transition: opacity 0.8s ease;
  }
  #loading.hidden { opacity: 0; pointer-events: none; }
  .lt {
    color: rgba(255,255,255,0.3);
    font-family: Georgia, serif;
    font-size: 10px; letter-spacing: 0.35em;
    text-transform: uppercase; margin-bottom: 18px;
  }
  .lb { width: 140px; height: 1px; background: rgba(255,255,255,0.1); overflow: hidden; }
  .lf { height: 100%; background: rgba(255,255,255,0.5); width: 0%; transition: width 0.08s linear; }
</style>
</head>
<body>

<div id="loading">
  <p class="lt">Loading</p>
  <div class="lb"><div class="lf" id="lf"></div></div>
</div>

<canvas id="c"></canvas>
<div id="fade"></div>

<div id="hint">
  <span>Scroll</span>
  <svg width="16" height="16" viewBox="0 0 16 16" fill="none">
    <path d="M8 2v12M3 9l5 5 5-5" stroke="rgba(255,255,255,0.4)" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
  </svg>
</div>

<div id="scroller">
  <div id="scroll-content"></div>
</div>

<script>
  const BASE       = 'https://raw.githubusercontent.com/CarmelloVision/sushi/main/';
  const TOTAL      = 192;
  const FRAME_STEP = 2;
  const EFFECTIVE  = Math.ceil(TOTAL / FRAME_STEP);
  const PRELOAD    = 5;
  const BUMP_PX    = window.screen.height;

  function fname(i) {
    return `frame_${String(i).padStart(3,'0')}_delay-0.041s.jpg`;
  }

  const canvas   = document.getElementById('c');
  const ctx      = canvas.getContext('2d');
  const scroller = document.getElementById('scroller');
  const lf       = document.getElementById('lf');
  const loader   = document.getElementById('loading');
  const fade     = document.getElementById('fade');
  const hint     = document.getElementById('hint');

  const imgs  = {};
  let loadCount = 0, ready = false;
  let cur = 0, tgt = 0, ticking = false;
  let bumpSent = false;

  // ── Resize ────────────────────────────────────────────────────
  function resize() {
    canvas.width  = window.innerWidth;
    canvas.height = window.innerHeight;
    drawFrame(cur);
  }
  window.addEventListener('resize', resize);
  resize();

  // ── Draw ──────────────────────────────────────────────────────
  function drawImg(img) {
    const cw = canvas.width, ch = canvas.height;
    const s  = Math.max(cw / img.naturalWidth, ch / img.naturalHeight);
    const dw = img.naturalWidth * s, dh = img.naturalHeight * s;
    ctx.clearRect(0, 0, cw, ch);
    ctx.drawImage(img, (cw - dw) / 2, (ch - dh) / 2, dw, dh);
  }

  function drawFrame(frameIdx) {
    const nearest = Math.round(frameIdx / FRAME_STEP) * FRAME_STEP;
    const clamped = Math.min(TOTAL - FRAME_STEP, Math.max(0, nearest));
    const img     = imgs[clamped];
    if (!img?.complete || !img.naturalWidth) {
      for (let o = FRAME_STEP; o < 30; o += FRAME_STEP) {
        const f = imgs[Math.max(0, clamped - o)];
        if (f?.complete && f.naturalWidth) { drawImg(f); return; }
      }
      return;
    }
    drawImg(img);
  }

  // ── Seek — works in both directions ───────────────────────────
  function seek() {
    if (Math.abs(cur - tgt) < FRAME_STEP) {
      cur = tgt;
      ticking = false;
      return;
    }
    const diff = tgt - cur;
    cur += Math.sign(diff) * Math.max(FRAME_STEP, Math.round(Math.abs(diff) * 0.35));
    cur  = Math.min(TOTAL - 1, Math.max(0, cur));
    drawFrame(cur);
    if (Math.abs(cur - tgt) >= FRAME_STEP) requestAnimationFrame(seek);
    else { cur = tgt; ticking = false; }
  }

  function setTarget(frameIdx) {
    tgt = Math.min(TOTAL - 1, Math.max(0, frameIdx));
    if (!ticking) { ticking = true; seek(); }
  }

  // ── Internal scroller — drives animation forward AND backward ─
  scroller.addEventListener('scroll', () => {
    if (!ready) return;

    const maxScroll = scroller.scrollHeight - scroller.clientHeight;
    const progress  = scroller.scrollTop / maxScroll;
    setTarget(Math.floor(progress * TOTAL));

    hint.classList.remove('visible');

    // Forward complete — bump parent down, release scroller
    if (progress >= 0.95 && !bumpSent) {
      bumpSent = true;
      fade.style.opacity = '0';
      setTimeout(() => {
        scroller.classList.add('done');
        try { window.parent.scrollBy({ top: BUMP_PX, behavior: 'smooth' }); } catch(e) {}
        try { window.top.scrollBy({ top: BUMP_PX, behavior: 'smooth' }); } catch(e) {}
      }, 300);
    }

    // Rewound all the way back to start
    if (progress <= 0.02) {
      fade.style.opacity = '1';
      bumpSent = false;
    }
  }, { passive: true });

  // ── Parent scroll messages ─────────────────────────────────────
  window.addEventListener('message', (e) => {
    if (!e.data || !ready) return;

    // Parent scrolled back up — re-engage animation in reverse
    if (e.data.action === 'reEngage') {
      // Re-enable scroller
      scroller.classList.remove('done');
      // Set scroller to bottom so scrolling up plays in reverse
      const maxScroll = scroller.scrollHeight - scroller.clientHeight;
      scroller.scrollTop = maxScroll;
      // Show the fade again
      fade.style.opacity = '1';
      bumpSent = false;
    }

    // Parent scrolled all the way back above iframe — full reset
    if (e.data.action === 'resetScroller') {
      scroller.classList.remove('done');
      scroller.scrollTop = 0;
      setTarget(0);
      fade.style.opacity = '1';
      bumpSent = false;
    }
  });

  // ── Hint ──────────────────────────────────────────────────────
  setTimeout(() => {
    if (ready && scroller.scrollTop < 10) hint.classList.add('visible');
  }, 2000);

  // ── Fallback: force show after 8s ─────────────────────────────
  setTimeout(() => {
    if (!ready) {
      ready = true;
      drawFrame(0);
      loader.classList.add('hidden');
    }
  }, 8000);

  // ── Load frames ───────────────────────────────────────────────
  for (let i = 0; i < TOTAL; i += FRAME_STEP) {
    const img       = new Image();
    img.crossOrigin = 'anonymous';
    img.src         = BASE + fname(i);
    img.onload = () => {
      loadCount++;
      lf.style.width = Math.round((loadCount / EFFECTIVE) * 100) + '%';

      // Draw immediately on first image
      if (loadCount === 1) {
        canvas.width  = window.innerWidth;
        canvas.height = window.innerHeight;
        drawImg(img);
      }

      if (loadCount === PRELOAD && !ready) {
        ready = true;
        resize();
        drawFrame(0);
        loader.classList.add('hidden');
        setTimeout(() => {
          if (scroller.scrollTop < 10) hint.classList.add('visible');
        }, 2000);
      }
    };
    img.onerror = () => { loadCount++; };
    imgs[i] = img;
  }
</script>
</body>
</html>
